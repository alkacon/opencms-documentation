import org.apache.tools.ant.filters.ReplaceTokens
apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'eclipse'

sourceCompatibility = java_target_version
targetCompatibility = java_target_version

buildDir = build_directory
project.ext.currentDate=new Date().format('dd.MM.yy')
project.ext.modulesDistsDir = file("${project.buildDir}/modulesZip")
project.ext.moduleLibs=''
project.ext.dependencyLibs=''
project.ext.modulesAll=''

if (!project.hasProperty('max_heap_size')){
    project.ext.max_heap_size='1024m'
}

Properties props = new Properties()
props.load(new FileInputStream("$projectDir/all-modules.properties"))
project.ext.allModuleNames = props['modules.common.all']
project.ext.modulesDistsDir = file("${project.buildDir}/modulesZip")

repositories {
    mavenLocal()
    if (project.hasProperty('additional_repositories')){
        additional_repositories.split(';').each{ repo ->
            maven { url repo }
        }
    }
    jcenter()
    maven {
    	url "http://maven.nuiton.org/release/"
    }
    maven {
    	url "http://software.rescarta.org/nexus/content/repositories/thirdparty/"
    }
    maven {
    	url "http://maven.vaadin.com/vaadin-addons"
    }
}

configurations {
	moduleDeps {
    	description = 'additional dependencies required by modules, need to be added into the webapp lib folder'
    }
	compile {
		description = 'used to compile the modules jars'
		extendsFrom moduleDeps
    }
    testCompile {
        extendsFrom compile
    }
}

sourceSets {
    test {
        java {
                srcDir "test/src"
        }
        compileClasspath=configurations.testCompile
    }
}

// import dependencies
apply from: 'dependencies.gradle'

task wrapper(type: Wrapper){
	gradleVersion = '4.10'
}

//task testAll (type: Test)

allModuleNames.split(',').each{ moduleName ->
    sourceSets.create(moduleName,{
        java {
            srcDir "${moduleName}/src"
        }
        resources.srcDir "${moduleName}/src"
    });
   sourceSets[moduleName].compileClasspath=configurations.compile
    def moduleFolder = file("${moduleName}")
    def srcGwtDir = file("${moduleFolder}/src")
    def staticFolder=file("${moduleFolder}/static")
    def requiresJar = srcGwtDir.exists() || staticFolder.exists()
    def manifestFile = file("${moduleFolder}/resources/manifest.xml")
    def gwtModule = null
    def gwtSourceSetName = null
    def propertyFile = file("${moduleFolder}/module.properties")
    def gwtRename = null
    if (propertyFile.exists()){
        println "checking properties for module $moduleName"
        Properties moduleProperties= new Properties()
        moduleProperties.load(new FileInputStream(propertyFile))
        if (moduleProperties['module.gwt']!=null){
            gwtModule = moduleProperties['module.gwt']
            gwtSourceSetName = moduleName.replace(".", "_")+'_gwt'
            println "found GWT module $gwtModule"
            def moduleXml = (new XmlParser()).parse(srcGwtDir.toString()+"/" +gwtModule.replaceAll('\\.','/')+'.gwt.xml')
            gwtRename = moduleXml['@rename-to']
            if (gwtRename==null){
                gwtRename=gwtModule
            }
        }
    }
    def testDir = file("${moduleFolder}/test")
    def requiresTest = testDir.exists()
    if (requiresTest){
       sourceSets.test.compileClasspath += files(sourceSets[moduleName].java.outputDir) { builtBy sourceSets[moduleName].compileJavaTaskName }
       sourceSets.test.runtimeClasspath += files(sourceSets[moduleName].java.outputDir) { builtBy sourceSets[moduleName].compileJavaTaskName }
       sourceSets.test.java.srcDir "${moduleName}/test"
    }
    def moduleDependencies=[]
    def moduleVersion = version
    if (manifestFile.exists()){
        def parsedManifest= (new XmlParser()).parse("${moduleFolder}/resources/manifest.xml")
        parsedManifest.module[0].dependencies[0].dependency.each{ dep ->
            moduleDependencies.add(dep.@name)
        }
        moduleVersion = parsedManifest.module[0].version[0].text()
    }
    if (requiresJar.toBoolean()) {
	    task "jar_$moduleName" (type: Jar) {
	        ext.moduleName = moduleName
	        ext.moduleVersion= moduleVersion
	        manifest {
	            attributes 'Implementation-Title': 'OpenCms documentation', 'Implementation-Version': moduleVersion
	        }
	        from sourceSets[moduleName].output
	        from ("$staticFolder") { into "OPENCMS" }
	        archiveName moduleName+'.jar'
	        baseName moduleName
	        exclude '**/.gitignore'
	        doFirst {
	            println '======================================================'
	            println "Building JAR for $moduleName version $moduleVersion"
	            println '======================================================'
	        }
	    }
    }
    if (requiresTest.toBoolean()) {
        task "test_$moduleName" (type: Test, dependsOn: sourceSets.test.compileJavaTaskName) {
            useJUnit()
            classpath += sourceSets.test.compileClasspath
            classpath += files(sourceSets.test.java.outputDir)
            include "**/Test*"
            // important: exclude all anonymous classes
            exclude '**/*$*.class'
            scanForTestClasses false
            testClassesDirs = files(sourceSets.test.java.outputDir)
            systemProperties['db.product'] = "hsqldb"
            systemProperties['test.data.path'] = "${projectDir}/test/data"
            systemProperties['test.webapp.path'] = "${projectDir}/test/webapp"
            systemProperties['test.build.folder'] =sourceSets.test.output.resourcesDir
            maxHeapSize = max_heap_size
            jvmArgs '-XX:MaxPermSize=256m'
            testLogging.showStandardStreams = true
            ignoreFailures true
        }
    }
    task "dist_$moduleName" (type: Zip){
        ext.moduleName = moduleName
        ext.moduleFolder = moduleFolder
        ext.dependencies = moduleDependencies
        ext.gwtSourceSetName = gwtSourceSetName
        ext.gwtRenameTo = gwtRename
        ext.requiresJar = requiresJar
        ext.requiresTest = requiresTest
        if (project.hasProperty('noVersion')) {
        	version
        	project.modulesAll +="${moduleName}.zip,"
        } else {
         	version moduleVersion
         	project.modulesAll +="${moduleName}-${moduleVersion}.zip,"
        }
        destinationDir modulesDistsDir
        baseName moduleName
        doFirst {
            println '======================================================'
            println "Building ZIP for $moduleName version $moduleVersion"
            println '======================================================'
        }
        // excluding jars from modules, jars will be placed in the WEB-INF lib folder through the deployment process
        from("${moduleFolder}/resources"){
        	exclude '**/lib*/*.jar'
        }
    }
    if (requiresJar.toBoolean()) {
        tasks["dist_$moduleName"].dependsOn("jar_$moduleName")
        project.moduleLibs+="${moduleName}.jar,"
    }

    if (gwtModule != null){
        println "creating sourceset for $gwtModule"

        sourceSets.create(gwtSourceSetName,{
            java {
                srcDirs srcGwtDir
                exclude '**/test/**'
            }
            resources {
                srcDirs srcGwtDir
            }
        })
        sourceSets[gwtSourceSetName].compileClasspath=configurations.compile
        task "gwt_$moduleName" (dependsOn: "${gwtSourceSetName}Classes", type: JavaExec) {
            ext.buildDir =  project.buildDir.toString()  +"/gwt/$moduleName"
            ext.extraDir =  project.buildDir.toString() + "/extra/$moduleName"
            ext.moduleName = moduleName
            inputs.source sourceSets[gwtSourceSetName].java.srcDirs
            inputs.dir sourceSets[gwtSourceSetName].output.resourcesDir
            outputs.dir buildDir

            // Workaround for incremental build (GRADLE-1483)
            outputs.upToDateSpec = new org.gradle.api.specs.AndSpec()

            doFirst {
                println '======================================================'
                println "Building GWT resources for $gwtModule"
                println '======================================================'
                // to clean the output directory, delete it first
                def dir = file(buildDir)
                if (dir.exists()){
                    delete(dir)
                }
                dir.mkdirs()
            }

            main = 'com.google.gwt.dev.Compiler'

            classpath {
                [
                    sourceSets[moduleName].java.srcDirs,
                    sourceSets[moduleName].compileClasspath,
                    sourceSets[gwtSourceSetName].java.srcDirs,
                    sourceSets[gwtSourceSetName].output.resourcesDir,
                    sourceSets[gwtSourceSetName].output.classesDir
                ]
            }


            args =
                    [
                        gwtModule,
                        // Your GWT module
                        '-war',
                        buildDir,
                        '-logLevel',
                        'INFO',
                        '-localWorkers',
                        '2',
                        '-style',
                        'obfuscated',
                        '-extra',
                        extraDir,
                        '-strict'
                        // '-draftCompile' // Speeds up compile with 25%
                    ]

            maxHeapSize = max_heap_size
        }

        tasks["dist_$moduleName"].dependsOn tasks["gwt_$moduleName"]
    }
}

task copyDeps(type: Copy){
	from configurations.moduleDeps
    into "${buildDir}/deps"
}

task copyProjectProps(type: Copy){
	configurations.moduleDeps.each {d ->
			project.dependencyLibs="${project.dependencyLibs}${d.name},"
	}
	from(projectDir) {
        include 'project.properties'
        filter(ReplaceTokens, tokens: [
        	MODULES_ALL: ''+project.modulesAll,
        	MODULE_LIBS: ''+project.moduleLibs,
            DEPENDENCY_LIBS: ''+project.dependencyLibs
        ])

    }
    into modulesDistsDir
}

task bindist(dependsOn: [copyDeps, copyProjectProps]) {
    doFirst{
        println 'Done'
    }
}

task documentationAllJar(type: Jar){
	allModuleNames.split(',').each{ moduleName ->
		from sourceSets[moduleName].output
	}
	baseName 'documentation-all'
    exclude '**/.gitignore'
    exclude '**/test/**'
    doFirst {
        println '======================================================'
        println "Building JAR for DOCUMENTATION ALL"
        println '======================================================'
	}
}

task documentationAllJavadoc (type: Javadoc){
	allModuleNames.split(',').each{ moduleName ->
    	source += sourceSets[moduleName].allJava
    	classpath += project.sourceSets[moduleName].compileClasspath
    }
    destinationDir = file("${buildDir}/docs/documentationAllJavadoc")
    options.addStringOption("sourcepath", "")
}

task documentationAllJavadocJar(dependsOn: documentationAllJavadoc, type: Jar) {
 	classifier 'javadoc'
    from "${buildDir}/docs/documentationAllJavadoc"
    baseName 'documentation-all'
}

task documentationAllSourcesJar(type: Jar) {
	allModuleNames.split(',').each{ moduleName ->
    	from sourceSets[moduleName].allSource
    }
    classifier 'sources'
    baseName 'documentation-all'
}

tasks.findAll{ task -> task.name.startsWith('dist_')}.each{ dist_task ->
    dist_task.dependencies.each{ dep ->
        def depCompileName = 'compile'+dep.replaceAll('\\.','')+'java'
        tasks.findAll{ comp_task -> comp_task.name.toLowerCase().equals(depCompileName)}.each {comp_task ->
            sourceSets[dist_task.moduleName].compileClasspath += files(sourceSets[dep].java.outputDir) { builtBy comp_task.name }
            if (dist_task.gwtSourceSetName!=null){
                sourceSets["${dist_task.gwtSourceSetName}"].compileClasspath += files(sourceSets[dep].java.outputDir) { builtBy comp_task.name }
            }
            if (dist_task.requiresTest.toBoolean()){
                sourceSets.test.compileClasspath += files(sourceSets[dep].java.outputDir) { builtBy comp_task.name }
                sourceSets.test.runtimeClasspath += files(sourceSets[dep].java.outputDir) { builtBy comp_task.name }
            }
        }
    }

    if (dist_task.requiresJar.toBoolean()){
	    tasks['jar_'+dist_task.moduleName].dependsOn{
	        tasks.findAll{ comp_task -> comp_task.name.toLowerCase().equals('compile'+dist_task.moduleName.replaceAll('\\.','')+'java')}
	    }
    }
    bindist.dependsOn dist_task
    documentationAllJar.dependsOn{
        tasks.findAll{ comp_task -> comp_task.name.toLowerCase().equals('compile'+dist_task.moduleName.replaceAll('\\.','')+'java')}
    }
}

// fixed issue with libraries containing both .java and .class files
tasks.withType(JavaCompile) {
    options.compilerArgs += ["-sourcepath", ""]
}
artifacts {
    archives documentationAllJar
    archives documentationAllSourcesJar
    archives documentationAllJavadocJar
}

install {
    repositories {
        mavenInstaller {
        	addFilter('documentation-all'){artifact, file ->
                artifact.name.startsWith('documentation-all')
            }
            pom('documentation-all').project {
                name 'Documentation all'
                description 'Documentation all modules'
                packaging 'jar'
                groupId 'com.alkacon'
                url 'http://www.alkacon.com'
                version documentation_all_version
                licenses {
                    license {
                        name 'GNU General Public License'
                        url 'http://www.gnu.org/licenses/gpl.html'
                        distribution 'repo'
                    }
                }
                organization {
                    name 'Alkacon Software'
                    url 'http://www.alkacon.com'
                }
                developers {
                    developer {
                        name 'Alkacon Software'
                        url 'http://www.alkacon.com'
                    }
                }
            }
        }
    }
}

/** Necessary to let eclipse run test cases. */
eclipse.classpath.file {
    whenMerged { classpath ->
        classpath.entries.each {entry ->
            if (entry.kind == 'src') {
                if (entry.path.endsWith("src")) {
                    entry.output='bin/main'
                }
            }
        }
    }
}